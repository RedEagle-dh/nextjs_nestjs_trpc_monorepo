# Package: @mono/database

This package is the single source of truth for all data-related concerns in the monorepo. It defines the database schema, generates the API contract, and provides typed clients for both the frontend and backend to consume.

## Table of Contents

- [Core Technologies](#core-technologies)
- [Key Concepts & Architecture](#key-concepts--architecture)
- [Package Structure](#package-structure)
- [How to Use (Package Exports)](#how-to-use-package-exports)
- [Available Scripts](#available-scripts)
- [Development Workflow](#development-workflow)

---

## Core Technologies

-   **[Prisma](https://www.prisma.io/):** The underlying ORM used for database schema migrations and raw database access.
-   **[ZenStack](https://zenstack.dev/):** A toolkit built on top of Prisma. It uses the `schema.zmodel` file to add a layer of access control policies and to auto-generate fully-typed tRPC routers and Zod schemas.
-   **[tRPC](https://trpc.io/):** Used to create a fully type-safe API layer. The entire API contract (`AppRouter`) is defined here and shared across the monorepo.
-   **[Zod](https://zod.dev/):** Used for schema declaration and validation for API inputs and outputs.

---

## Key Concepts & Architecture

The data layer is built with a "schema-first" approach, where the `schema.zmodel` file is the ultimate source of truth.

1.  **Data Model (`schema.zmodel`):** You define your data models here, just like in a `schema.prisma` file, but with the added power of ZenStack's access policy attributes (e.g., `@@allow`, `@@deny`).

2.  **Code Generation (`pnpm generate`):** Running the `generate` script does two things:
    -   **Prisma Schema:** ZenStack generates a standard `prisma/schema.prisma` file from your `schema.zmodel`.
    -   **tRPC Routers & Zod Schemas:** ZenStack generates fully-typed tRPC routers for all your models (CRUD operations) and corresponding Zod schemas for validation. These are placed in `src/zenstack`.

3.  **API Contract (`trpc-contract.ts`):** This is the centerpiece of the package. It is an **auto-generated file** created by a script in the `apps/backend` package. It merges:
    -   The auto-generated tRPC routers from ZenStack.
    -   Your custom-defined tRPC routers (like `auth` or `healthcheck`).

    The resulting `appRouter` and its type `AppRouter` represent the **complete API contract**. This contract is then imported by the frontend to create a fully type-safe client.

4.  **tRPC Setup (`trpc.ts`):** This file contains the tRPC initialization and core middleware. It exports procedures for building your API:
    -   `publicProcedure`: For endpoints that do not require authentication.
    -   `protectedProcedure`: For endpoints that require a valid user session. It uses a middleware to check for `ctx.session.user`.

---

## Package Structure

```
.
├── /dist/              # Compiled output (JavaScript and type definitions)
├── /generated/         # Raw generated prisma files from ZenStack (copied during build)
├── /prisma/
│   └── schema.prisma   # The Prisma schema, GENERATED by ZenStack. Do not edit directly.
├── /src/
│   ├── /generated/     # Routers and Router Types, GENERATED by ZenStack.
│   ├── /zenstack/      # Zod schemas, GENERATED by ZenStack.
│   ├── context.ts      # Defines the tRPC context shape.
│   ├── generated.provider.ts # NestJS provider for the generated router.
│   ├── trpc.ts         # Core tRPC setup (init, router, procedures, middleware).
│   └── trpc-contract.ts# The full API contract, GENERATED by the backend.
├── package.json
└── schema.zmodel       # The single source of truth for your data model and access policies.
```

---

## How to Use (Package Exports)

This package is designed to be consumed by other packages in the monorepo using specific entry points defined in `package.json`.

| Import Path | Provides | Used In |
| :--- | :--- | :--- |
| `@mono/database` | Core tRPC types and context (`TRPCContext`). | `apps/backend` |
| `@mono/database/contract` | The main `AppRouter` type and `appRouter` object. | `apps/backend`, `apps/frontend` |
| `@mono/database/zenstack` | Zod schemas for all your models. | `apps/backend`, `apps/frontend` |
| `@mono/database/trpc/react` | Type-safe React Query hooks for the frontend. | `apps/frontend` |
| `@mono/database/prisma/client` | The raw, generated Prisma Client instance. | `apps/backend` |

---

## Available Scripts

| Script | Description |
| :--- | :--- |
| `pnpm build` | Compiles the TypeScript source code into the `dist` directory. |
| `pnpm dev` | Runs the TypeScript compiler in watch mode for development. |
| `pnpm generate` | **Important:** Generates Prisma schema and tRPC/Zod files from `schema.zmodel`. |
| `pnpm migrate` | Pushes the current Prisma schema state to the database. **Use with caution.** |

---

## Development Workflow

Follow these steps to add a new model or API endpoint.

### A) Adding a new Data Model (e.g., "Post")

1.  **Edit the Schema:** Open `schema.zmodel` and add your new model, including fields and access policies.
    ```zmodel
    model Post {
      id    String @id @default(cuid())
      title String
      // ... other fields

      // Allow all logged-in users to read posts
      @@allow('read', auth() != null)
    }
    ```
2.  **Generate Code:** Run `pnpm generate` in this package. This will update `prisma/schema.prisma` and create new tRPC routers and Zod schemas in `src/zenstack`.
3.  **Update Database:** Run `pnpm migrate` to apply the schema changes to your database.
4.  **Regenerate Contract:** The backend needs to be aware of the new generated router. Run the contract generation script in the `apps/backend` package (e.g., `pnpm --filter=backend generate:trpc-contract`). This updates `trpc-contract.ts`.
5.  **Done!** The new `post` router is now part of the `AppRouter` and can be used in the frontend with full type safety.

### B) Adding a new Custom API Endpoint

The logic for custom API endpoints (e.g., for authentication, file uploads, etc.) does **not** live in this `database` package. It is defined and implemented exclusively in the `apps/backend` package.

This `database` package only consumes the **auto-generated contract** that the backend produces.

The high-level workflow is as follows:

1.  **Implement in Backend:** Navigate to the `apps/backend` package to define your new tRPC router and implement its logic.
2.  **Generate Contract:** Run the contract generation script from within the `apps/backend` package (e.g., `pnpm --filter=backend generate:trpc-contract`).
3.  **Result:** This script will automatically update the `trpc-contract.ts` file inside **this** package (`@mono/database`) with the new API structure.

**For a detailed, step-by-step guide, please refer to the `README.md` in the `apps/backend` package.**