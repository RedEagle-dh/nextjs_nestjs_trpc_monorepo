// AUTOGENERATED FILE - DO NOT EDIT MANUALLY

import { TRPCError, initTRPC } from "@trpc/server";
import { z } from "zod";
import type { TRPCContext } from "./server.ts";

const t = initTRPC.context<TRPCContext>().create();

export const publicProcedure = t.procedure;
export const protectedProcedure = t.procedure.use(async (opts) => {
	// This middleware is a placeholder for the generated contract.
	// Actual authentication and authorization logic resides in the backend.
	// It ensures that procedures marked as protected in the contract
	// are recognizable as such by the tRPC client and type system.
	if (!opts.ctx.user && opts.path !== "healthcheck") {
		/* Example to allow healthcheck */
		// console.warn(`[tRPC Contract] Protected procedure '${opts.path}' called without user context.`);
		// throw new TRPCError({ code: 'UNAUTHORIZED' }); // Optional: make contract stricter
	}
	return opts.next({ ctx: opts.ctx });
});

export const appRouter = t.router({
	user: t.router({
		getHealthcheck: publicProcedure
			.input(z.string())
			.output(
				z.object({
					status: z.string(),
					timestamp: z.string(),
				}),
			)
			.query(({ input, ctx }) => {
				console.warn(
					"tRPC contract placeholder for 'user.getHealthcheck' called.",
				);
				return {
					status: "PLACEHOLDER_STRING",
					timestamp: "PLACEHOLDER_STRING",
				};
			}),
	}),
	ping: publicProcedure
		.input(z.undefined()) // Kein Input
		.query(() => {
			return "pong";
		}),
});

export type AppRouter = typeof appRouter;
