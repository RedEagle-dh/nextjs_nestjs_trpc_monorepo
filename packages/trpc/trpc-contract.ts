// AUTOGENERATED FILE - DO NOT EDIT MANUALLY

import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';
import type { TRPCContext } from './server.ts';

// Local Dependencies (Types, Enums, Schemas)
const loginInputSchema = z.object({
	email: z.string().email(),
	password: z.string(),
});

const loginOutputSchema = z.object({
	token: z.string(),
});

const t = initTRPC.context<TRPCContext>().create();

export const publicProcedure = t.procedure;
export const protectedProcedure = t.procedure.use(async (opts) => {
  // This middleware is a placeholder for the generated contract.
  // Actual authentication and authorization logic resides in the backend.
  if (!opts.ctx.user && opts.path !== 'healthcheck') { /* Example to allow healthcheck */ 
    // console.warn(`[tRPC Contract] Protected procedure '${opts.path}' called without user context.`);
    // throw new TRPCError({ code: 'UNAUTHORIZED' }); // Optional: make contract stricter
  }
  return opts.next({ ctx: opts.ctx });
});

export const appRouter = t.router({
  auth: t.router({
    login: publicProcedure
      .input(loginInputSchema)
      .output(loginOutputSchema)
      .mutation(({ input, ctx }) => {
        return { "token": "PLACEHOLDER_STRING" };
      }),
  }),
  user: t.router({
    getHealthcheck: publicProcedure
      .input(z.string())
      .output(z.object({
			status: z.string(),
			timestamp: z.string(),
		}))
      .query(({ input, ctx }) => {
        return { "status": "PLACEHOLDER_STRING", "timestamp": "PLACEHOLDER_STRING" };
      }),
    mutateHealthcheck: publicProcedure
      .input(z.object({
			healthcheck: z.string(),
		}))
      .output(z.object({
			status: z.string(),
			timestamp: z.string(),
		}))
      .mutation(({ input, ctx }) => {
        return { "status": "PLACEHOLDER_STRING", "timestamp": "PLACEHOLDER_STRING" };
      }),
    protectedHealthcheck: protectedProcedure
      .input(z.object({
			healthcheck: z.string(),
		}))
      .output(z.object({
			status: z.string(),
			timestamp: z.string(),
		}))
      .mutation(({ input, ctx }) => {
        return { "status": "PLACEHOLDER_STRING", "timestamp": "PLACEHOLDER_STRING" };
      }),
  }),
});

export type AppRouter = typeof appRouter;
